#+title: JCC: A C compiler written in Julia

* Links

- [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf][latest revision of the C99 standard]]
- [[http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf][An Incremental Approach to Compiler Construction (A. Ghuloum)]]

* Plan

Follow Ghuloum's paper closely, by making a working interpreter for
[[file:test.c]].

* Julia specific

- [[https://docs.julialang.org/en/v1/manual/workflow-tips/][REPL-based workflow]]
- [[https://discourse.julialang.org/t/proper-way-of-organizing-code-into-subpackages/52835/5][Useful links for module usage]]
- [[https://docs.julialang.org/en/v1/manual/modules/#Submodules-and-relative-paths][Modules - Julia documentation]]
- for jump to definition: can simply use ~etags *.jl~
- default equality test for structures compare fields using ~===~
  (identity), not ~==~ (equality). Define it manually to i.e. compare
  ASTs.
- see =AST.BinaryOp= for an example of how to define mutually
  recursive types

* Dump of things to implement
- my own assembler
- my own linker
- constant propagation / static optimizations (i.e. replace =40+2= by
  =42=)
- proper type checking

* Notes

** TODO Make the test run inside a temporary dir

** TODO Try compiling a program with addition of literals

How does the stack work ?
- assume everything writes to =%eax=
- if a binary op:
  - compile first subexp
  - save eax to the stack
  - compile second subexp
  - add the two, and save to =%eax=
- for this I need a way to keep track of the stack size
  - I can change io to context, and use a single global

** TODO Unary primitives

Will be simpler than binary ops.
- is =-10= parsed as an unary op or a constant ? :: as an unary op

** Implementing assembly generation
   
- how is a function organized ?
  - return type :: 
  - declarator :: to simplify, =function_name(function_params)=
  - compound statement for the body
- =_start= will be the entry point, and will call =main=, to make it
  like an ordinary function, able to use =ret= and so on

** Notes about assembly
   
- use AT&T syntax, since it is what's used by Ghuloum and the GNU
  Assembler

Size suffixes:
| suffix      | b    | s                    | w    | l                    | q    | t        |
| meaning     | byte | short / single       | word | long                 | quad | ten      |
|-------------+------+----------------------+------+----------------------+------+----------|
| size (bits) | 8    | 16 (int), 32 (float) | 16   | 32 (int), 64 (float) | 64   | 80 float |
