#+title: JCC: A C compiler written in Julia

* Links

- [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf][latest revision of the C99 standard]]
- [[http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf][An Incremental Approach to Compiler Construction (A. Ghuloum)]]

* Plan

Follow Ghuloum's paper closely. 

* Julia specific

- [[https://docs.julialang.org/en/v1/manual/workflow-tips/][REPL-based workflow]]
- [[https://discourse.julialang.org/t/proper-way-of-organizing-code-into-subpackages/52835/5][Useful links for module usage]]
- [[https://docs.julialang.org/en/v1/manual/modules/#Submodules-and-relative-paths][Modules - Julia documentation]]
- for jump to definition: can simply use ~etags *.jl~
- default equality test for structures compare fields using ~===~
  (identity), not ~==~ (equality). Define it manually to i.e. compare
  ASTs.
- see =AST.BinaryOp= for an example of how to define mutually
  recursive types

* Dump of things to implement
- my own assembler
- my own linker
- constant propagation / static optimizations (i.e. replace =40+2= by
  =42=)
- proper type checking

* Notes

** TODO Make the test run inside a temporary dir

** DONE Try compiling a program with addition of literals

How does the stack work ?
- assume everything writes to =%eax=
- if a binary op:
  - compile first subexp
  - save eax to the stack
  - compile second subexp
  - add the two, and save to =%eax=
- for this I need a way to keep track of the stack size
  - I can change io to context, and use a single global

** DONE Unary primitives

Will be simpler than binary ops.
- is =-10= parsed as an unary op or a constant ? :: as an unary op

** TODO Local variables
- can variables be local to any compound statement in C99 ? :: yes I think
- how to deal with nested environments ?
  - use a stack (vector) of Dict{String, Int}
    - int to store often on the stack
    - pop this stack of envs, along with the stack counter when block
      is over
- first deal with assignment expressions
** Implementing assembly generation
   
- how is a function organized ?
  - return type :: 
  - declarator :: to simplify, =function_name(function_params)=
  - compound statement for the body
- =_start= will be the entry point, and will call =main=, to make it
  like an ordinary function, able to use =ret= and so on

** Notes about assembly
   
- use AT&T syntax, since it is what's used by Ghuloum and the GNU
  Assembler

Size suffixes:
| suffix      | b    | s                    | w    | l                    | q    | t        |
| meaning     | byte | short / single       | word | long                 | quad | ten      |
|-------------+------+----------------------+------+----------------------+------+----------|
| size (bits) | 8    | 16 (int), 32 (float) | 16   | 32 (int), 64 (float) | 64   | 80 float |
